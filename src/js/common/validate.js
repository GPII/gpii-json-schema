/*

A Fluid Component to handle JSON Schema validation.

Pass JSON content to this component's `validate(schemaKey, JSON)` invoker, and it
will be parsed using [AJV](https://github.com/epoberezkin/ajv).

You are expected to configure one or more schemas which will be read from `options.schemaContents`.  The `schemaKey`
value passed to `validate` is expected to match one of the keys in `options.schemaContent`.

You can change the behavior of AJV by updating `options.validatorOptions` (check their documentation for the syntax).

If there are no validation errors, we return `undefined`.  If there are validation errors, the raw output generated by
AJV is transformed using the static function `sanitizeValidationErrors`.

As an example, let's assume that you have a JSON payload like the following that you wish to validate:

  ```
  {
    field1: "invalid",
    category1: {
      nestedField1: "invalid"
    }
  }
  ```

Assuming that each value was invalid, you might see validation output like the following:

  ```
  {
    fieldErrors: {
      field1: ["should NOT be shorter than 8 characters", "should match pattern \"[A-Z]+\""],
      category1: {
        nestedField1: ["nested field is not a valid number."]
      }
  }
  ```

If you have configured your instance to work together with a `gpii.schema.parser`, it will further evolve the error
messages where possible.

 */

"use strict";
var fluid = fluid || require("infusion");
var gpii  = fluid.registerNamespace("gpii");

var Ajv = require("ajv");

fluid.registerNamespace("gpii.schema.validator.ajv");

gpii.schema.validator.ajv.init = function (that) {
    // We persist a single AJV instance so that we can take advantage of its automatic compiling and caching.
    that.ajv = Ajv(that.options.validatorOptions); // jshint ignore:line

    gpii.schema.validator.ajv.refreshSchemas(that);
};

gpii.schema.validator.ajv.validate = function (that, key, content) {
    var contentValid = that.ajv.validate(key, content);
    if (!contentValid) {
        return (gpii.schema.validator.ajv.sanitizeValidationErrors(that, key, that.ajv.errors));
    }

    return undefined;
};


/*
 AJV gives us output like:

 [
     {
         "keyword": "minLength",
         "dataPath": ".password",
         "message": "should NOT be shorter than 8 characters"
     },
     {
         "keyword": "pattern",
         "dataPath": ".password",
         "message": "should match pattern \"[A-Z]+\""
     },
     {
         "keyword": "required",
         "dataPath": ".deep.required",
         "message": "is a required property"
     }
 ]

 We need to break this down so that the messages can be associated with individual model variables and associated form
 elements.  This allows us to show overall in-context feedback to the user.

 */
gpii.schema.validator.ajv.sanitizeValidationErrors = function (that, schemaKey, errors) {
    var sanitizedErrors = { fieldErrors: {}};

    fluid.each(errors, function (error) {
        // Errors are associated with the right field based on the `dataPath` received from AJV.
        var path = gpii.schema.validator.ajv.extractPathSegmentsFromError(error);

        var errorMessage      = error.message;
        var overwriteExisting = false;

        var evolvedMessage = that.parser.lookupDescription(schemaKey, path);
        if (evolvedMessage) {
            errorMessage = evolvedMessage;
            overwriteExisting = true;
        }

        gpii.schema.validator.ajv.saveToPath(path, errorMessage, sanitizedErrors, overwriteExisting);
    });

    return sanitizedErrors;
};

/*

  AJV represents the location of validation failures using path notation like `.category.subcategory.field`.  This function
  converts that notation into a series of path segments that can be passed to `gpii.schema.validator.ajv.saveToPath`.

  Path segments with a literal period in their name are encoded like `sky.['middle.earth'].moria`.

  This function handles the general case as well as escaped variables, and converts them to a list of path segments
  like `["sky", "middle.earth", "moria"]`.  These segments are used in other functions to check for the existence of
  variables, etc.

 */
gpii.schema.validator.ajv.extractPathSegments = function (string) {
    var segments = [];

    // A regular expression to split the current segment and the remainder from one another. Handles variations like:
    //
    // 1. `simple.simon`
    // 2. `['kinda.complex'].simple`
    // 3. `simple['kinda.complex']`
    // 4. `['really.complex']['don\'t I know it']`
    //
    // See https://xkcd.com/1171/
    //
    // The matching within single quotes must be non-greedy to ensure that things like `['a.b']['c.d']` are treated as
    // separate segments.
    var slicingRegexp = /^\.?(\['.+?']|[^\[\.]+)([\[\.].+)$/;

    var remainingPath = string;

    // Iterate through, splitting by dots while preserving escaped dot notation (see above).
    var matches = remainingPath.match(slicingRegexp);
    while (matches) {
        segments.push(gpii.schema.validator.ajv.sanitizePathSegment(matches[1]));
        remainingPath = matches[2];
        matches = remainingPath.match(slicingRegexp);
    }

    // The last segment will not have two parts and can be added in its entirety
    segments.push(gpii.schema.validator.ajv.sanitizePathSegment(remainingPath));

    return segments;
};

/*

  Convenience function to extract the path segments from the `error` data structure returned by AJV.

 */
gpii.schema.validator.ajv.extractPathSegmentsFromError = function (error) {
    return gpii.schema.validator.ajv.extractPathSegments(error.dataPath);
};


/*

  Because dots are allowed in Javascript/JSON object keys, any segment with a dot is escaped by AJV.  The simplest
  example is `this.that`, which would be escaped as `['this.that']`.  This gives us three additional special characters,
  namely the square brackets and the single quote.

  If any of those are used, additional escaping is introduced, so `['this.that']` becomes `['[\\'this.that\\']']`.  This
  introduces the final special character, namely the backslash.

  If an escaped backslash is used, it is double escaped, so that `a\\b` becomes `a\\\\b`.

  This function takes care of reversing this process including all combinations, to ensure that we end up with the
  original unescaped literal key.

 */
gpii.schema.validator.ajv.sanitizePathSegment = function (segment) {
    // Discard any leading dot
    var segmentMinusLeadingDot = segment.replace(/^\./, "");

    // If we are surrounded by `['']`, extract the inner content and then unescape it.
    var hasSpecialRegexp = /\['(.+)'\]/;
    var specialMatches = segmentMinusLeadingDot.match(hasSpecialRegexp);
    if (specialMatches) {
        return specialMatches[1];
    }

    return segmentMinusLeadingDot;
};

// Resolve the underlying data from a hierarchical object using an array of path segments. Returns the portion of the
// original object at the selected path.  As an example:
//
// `resolveOrCreateTargetFromPath({ one: { two: { three: { four: "five"}}}}, ["one", "two", "three"])`
//
// Should return:
//
// `{ four: "five" }`
//
// Note that the relevant portion of the original object is returned, and not just the value.  If
// `createMissingSegments` is set, the deep structure will be created if it doesn't already exist, Thus:
//
// `resolveOrCreateTargetFromPath({}, ["one","two","three"], true)`
//
// Will return:
//
// `{ one: { two: { three: [] }}}`
//
// If you try to resolve a path that does not exist and `createMissingSegments` is not set, `undefined` will be returned.
//
gpii.schema.validator.ajv.resolveOrCreateTargetFromPath = function (target, path, createMissingSegments) {
    var value = fluid.get(target, path);
    if (!value && createMissingSegments) {
        value = [];
        fluid.set(target, path, value);
    }
    return value;
};

/*
  A function to save error messages to the right position within our "sanitized" JSON output (see header for example).

  `path`:
    An array of path segments pointing to a variable in `errorMap`.  If you are describing validation errors related to
    the field `category.subcategory.field`, the path would look like `["category", "subcategory", "field"]`.

  `errorString`:
    An error message to be saved to the right `path` within `errorMap`

  `errorMap`:
    A map of error messages for the whole document.  This will be modified with new values.

  `overwriteExisting`:
    Whether to overwrite what's found at path or append it to the array.  Used by the parser to collapse duplicate
    "evolved" messages into a single message.

 */
gpii.schema.validator.ajv.saveToPath = function (path, errorString, errorMap, overwriteExisting) {
    var target = errorMap.fieldErrors;
    target     = gpii.schema.validator.ajv.resolveOrCreateTargetFromPath(target, path, true);
    if (overwriteExisting) {
        target[0] = errorString;
    }
    else {
        target.push(errorString);
    }
};

/*

If we receive new schemas, make the validator aware of them so that we can simply validate using their key.

 */
gpii.schema.validator.ajv.refreshSchemas = function (that) {
    // Update the list of schemas using the supplied content
    fluid.each(that.model.schemas, function (schemaContent, schemaKey) {
        // AJV will not let us overwrite an existing schema , so we have to remove the current content first.
        if (that.ajv.getSchema(schemaKey)) {
            that.ajv.removeSchema(schemaKey);
        }

        try {
            that.ajv.addSchema(schemaContent, schemaKey);
        }
        catch (e) {
            fluid.fail("There was an error loading one of your JSON Schemas:", e);
        }
    });

    that.events.schemasLoaded.fire(that);
};

fluid.defaults("gpii.schema.validator.ajv", {
    gradeNames: ["fluid.modelComponent"],
    validatorOptions: {
        verbose: false,  // Prevent invalid data (such as passwords) from being displayed in error messages
        messages: true,  // Display human-readable error messages
        allErrors: true  // Generate a complete list of errors and not just the first failure.
    },
    events: {
        schemasLoaded: null
    },
    model: {
        schemas: {}
    },
    invokers: {
        validate: {
            funcName: "gpii.schema.validator.ajv.validate",
            args:     ["{that}", "{arguments}.0", "{arguments}.1"]
        }
    },
    listeners: {
        "onCreate.init": {
            funcName: "gpii.schema.validator.ajv.init",
            args:     ["{that}"]
        }
    },
    modelListeners: {
        "schemas": {
            funcName:      "gpii.schema.validator.ajv.refreshSchemas",
            excludeSource: "init",
            args:          ["{that}"]
        }
    },
    components: {
        parser: {
            type: "gpii.schema.parser",
            options: {
                schemaPath: "{gpii.schema.validator.ajv}.options.schemaPath",
                model: {
                    schemas: "{gpii.schema.validator.ajv}.model.schemas"
                }
            }
        }
    }
});

