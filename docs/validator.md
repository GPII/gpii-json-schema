# What is the validator?

JSON is a very flexible format, which allows it to cover a wide range of use cases.  However, in most cases you will
want to impose some practical limitations on the data you will accept.

[JSON Schema](http://json-schema.org/) is a standard for describing JSON data formats using JSON notation.  The
structure of a JSON schema roughly mirrors the structure of the JSON data being examined.

JSON Schemas provide a clear way to indicate what is and is not valid within a given JSON document.  You might use JSON
Schemas to validate a form's data on the client side before attempting to submit it to the server.  You might also
validate data and report errors whenever a component's model changes.

# How does it work?

This package provides client and server-side components that use [AJV](https://github.com/epoberezkin/ajv) to validate
supplied JSON data against a JSON Schema.  To use this on the client side, start with `gpii.schema.validator`.  To use
it on the server side, start with `gpii.schema.validator.server`.

The main work of the validator component is performed by its `validate(schemaKey, JSON)` invoker.  Here is an example
of how the validator might be used from within node:

    var fluid = require("infusion"");
    var gpii  = fluid.registerNamespace("gpii");

    require("gpii-json-schema");
    var validator = gpii.schema.validator({
        schemaContents: {
          sample: { "type": "object", "properties": { "required": { "type": "boolean" } }, "required": ["required"]}
        }
    });

    var errors = validator.validate("sample", { foo: "bar" });
    if (errors) {
        // Complain
    }
    else {
        // Rejoice
    }


If there are no validation errors, we return `undefined`.  If there are validation errors, the raw output generated by
AJV is transformed using the static function `sanitizeValidationErrors`.

As an example, let's assume that you have a JSON payload like the following that you wish to validate:

  ```
  {
    field1: "invalid",
    category1: {
      nestedField1: "invalid"
    }
  }
  ```

Assuming that each value was invalid, you might see validation output like the following:

  ```
  {
    fieldErrors: {
      field1: ["should NOT be shorter than 8 characters", "should match pattern \"[A-Z]+\""],
      category1: {
        nestedField1: ["nested field is not a valid number."]
      }
  }
  ```

This component is configured to work together with a `gpii.schema.parser` and to further evolve the error messages
where possible.  See [the parser documentation](parser.md) for details.

# Reusing Content between Schemas

One of the key strengths of JSON Schema is that it allows you to compose a complex schema out of parts taken from
other schemas.  The validator in this package supports references between JSON Schemas.

Inheritance is still a sticking point at least in v4 of the draft standard.   You cannot safely expect to overlay
multiple schemas on top of each other.  Best practice for now is to only reuse individual definitions between schemas,
and to explicitly specify each schema's required properties.

A limitation of this implementation is that it expects external references to use filenames rather than ids,
as in:

    $ref: "filename.json#/definitions/field"

This is a byproduct of `json-schema-ref-parser`, the library we use to evolve the error output. As this may change, best
practice is for the `id` in the schema to exactly match the filename.  See the `derived.json` and `base.json` test
schemas for an example.

# Components

## gpii.schema.validator.ajv

The common grade, designed for use on the client and server-side.

## gpii.schema.validator.ajv.server

A server-side component which additionally populates `schemaContents` for you on startup based on the contents of
`options.schemaPath`.  Because of limitations in the current AJV `parser`, the schema key must match the filename.

The server-side component will also resolve dependencies from `schemaContents`.  For example, if you have a second
schema that has a reference to `#schema-file-name.json`, it will resolve to the contents of `schemaContents["schema-file-name.json"]`.

# Component Options

The following component configuration options are supported:

| Option             | Type     | Description |
| ------------------ | -------- | ----------- |
| `schemaContents`   | `Object` | A map of raw JSON Schema content, keyed by filename. The `schemaKey` value passed to `validate` is expected to match one of the keys in `schemaContent`. |
| `validatorOptions` | `Object` | Options to be passed to our AJV validator instance (check [the AJV options documentation](https://github.com/epoberezkin/ajv#options) for the syntax and available options). |


# Invokers

## `gpii.schema.validator.ajv.validate(key, content)`

* `key {String}`:  The schema key we are validating against.
* `content {Object}`: The JSON content we are validating.
* Returns: An `{Object}` describing the errors, or `undefined` if there are no errors.

Transform raw validator output into a more human-readable form that corresponds to the structure of the original JSON
input.  Typically accessed using the validator component's `validate` invoker and the last two arguments.


## `gpii.schema.validator.ajv.sanitizeValidationErrors(schemaKey, errors)`

* `schemaKey {String}`: The schema key we are validating against.
* `errors`: A map of existing error results to be sanitized.

AJV gives us output like:

```
 [
     {
         "keyword": "minLength",
         "dataPath": ".password",
         "message": "should NOT be shorter than 8 characters"
     },
     {
         "keyword": "pattern",
         "dataPath": ".password",
         "message": "should match pattern \"[A-Z]+\""
     },
     {
         "keyword": "required",
         "dataPath": ".deep.required",
         "message": "is a required property"
     }
 ]
```

This invoker uses the [`parser`](parser.md) component in this package to replace `message` with custom error messages.  See that
module for details.

# Static Functions

## `gpii.schema.validator.ajv.extractPathSegments(string)`

* `string {String}`: The path segment in "dot notation" that we will extract a string from.
* Returns: An `{Array}` of path segments in `{String}` form.

AJV represents the location of validation failures using path notation like `.category.subcategory.field`.  This
function converts that notation into a series of path segments that can be passed to `gpii.schema.validator.ajv.saveToPath`.

Path segments with a literal period in their name are encoded like `sky.['middle.earth'].moria`.

This function handles the general case as well as escaped variables, and converts them to a list of path segments like
`["sky", "middle.earth", "moria"]`.

The arrays of segments produced by this function are used in other functions to check for the existence of variables, et
cetera.


## `gpii.schema.validator.ajv.sanitizePathSegment(segment)`

* `segment {String}`: The original path segment to be sanitized.
* Returns: A `{String}` representing the sanitized path segment.

Because dots are allowed in Javascript/JSON object keys, any segment with a dot is escaped by AJV.  The simplest example
is `this.that`, which would be escaped as `['this.that']`.  This gives us three additional special characters, namely
the square brackets and the single quote.

If any of those are used, additional escaping is introduced, so `['this.that']` becomes `['[\\'this.that\\']']`.  This
introduces the final special character, namely the backslash.

If an escaped backslash is used, it is double escaped, so that `a\\b` becomes `a\\\\b`.

This function takes care of reversing this process including all combinations, to ensure that we end up with the
original unescaped literal key.


## gpii.schema.validator.ajv.resolveOrCreateTargetFromPath(target, path, createMissingSegments)

* `target {Object}`:  The object to be inspected and possibly modified.
* `path {Array}`: An array of string path segments to be resolved relative to `target`.
* `createMissingSegments {Boolean}`: Whether or not to create missing segments if they do not already exist.
* Returns: The portion of the original object located at the selected path.

Resolve the underlying data from a hierarchical object using an array of path segments. Returns the portion of the
original object at the selected path.  As an example:

 `resolveOrCreateTargetFromPath({ one: { two: { three: { four: "five"}}}}, ["one", "two", "three"])`

Should return:

 `{ four: "five" }`

Note that the relevant portion of the original object is returned, and not just the value.  If
 `createMissingSegments` is set, the deep structure will be created if it doesn't already exist, Thus:

 `resolveOrCreateTargetFromPath({}, ["one","two","three"], true)`

Will return:

 `{ one: { two: { three: [] }}}`

If you try to resolve a path that does not exist and `createMissingSegments` is not set, `undefined` will be returned.

## `gpii.schema.validator.ajv.saveToPath(path, errorString, errorMap, overwriteExisting)`

* `path {Array}`: An array of path segments pointing to a variable in `errorMap`.  If you are describing validation errors related to the field `category.subcategory.field`, the path would look like `["category", "subcategory", "field"]`.
* `errorString {String}`: An error message to be saved to the right `path` within `errorMap`.
* `errorMap {Object}`: A map of error messages for the whole document.  This will be modified with new values.
* `overwriteExisting {Boolean}`: Whether to overwrite what's found at path or append it to the array.  Used by the parser to collapse duplicate"evolved" messages into a single message.
* Returns:  Nothing.  However, it does modify `errorMap`.

A function to save error messages to the right position within our "sanitized" JSON output (see above for example).
