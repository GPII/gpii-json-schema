# What is the validator?

JSON is a very flexible format, which allows it to cover a wide range of use cases.  However, in most cases you will
want to impose some practical limitations on the data you will accept.

[JSON Schema](http://json-schema.org/) is a standard for describing JSON data formats using JSON notation.  The
structure of a JSON schema roughly mirrors the structure of the JSON data being examined.

JSON Schemas provide a clear way to indicate what is and is not valid within a given JSON document.  You might use JSON
Schemas to validate a form's data on the client side before attempting to submit it to the server.  You might also
validate data and report errors whenever a component's model changes.

# How does it work?

This package provides client and server-side components that use [AJV](https://github.com/epoberezkin/ajv) to validate
supplied JSON data against a JSON Schema

The main work of the validator component is performed by its `validate(schemaKey, JSON)` invoker.  Here is an example
of how the validator might be used from within node:

    var fluid = require("infusion"");
    var gpii  = fluid.registerNamespace("gpii");

    require("gpii-json-schema");
    var validator = gpii.schema.validator({
        schemaContents: {
          sample: { "type": "object", "properties": { "required": { "type": "boolean" } }, "required": ["required"]}
        }
    });

    var errors = validator.validate("sample", { foo: "bar" });
    if (errors) {
        // Complain
    }
    else {
        // Rejoice
    }


If there are no validation errors, we return `undefined`.  If there are validation errors, the raw output generated by
AJV is transformed using the static function `sanitizeValidationErrors` (see below).

This component is configured to work together with schemas that have been dereferenced, i. e. where all references
to remote definitions have been reduced to the underlying JSON Schema rules.  See [the parser documentation](parser.md)
for details.

On the server-side, this is handled directly by a `gpii.schema.parser` instance.  On the client side, the
validator works with content retrieved from [a `gpii.schema.inline.router` instance](router.md), which is already
dereferenced.

# Components

## gpii.schema.validator.ajv

The common grade, designed for use on the client and server-side.

### Component Options

The following component configuration options are supported:

| Option             | Type     | Description |
| ------------------ | -------- | ----------- |
| `validatorOptions` | `Object` | Options to be passed to our AJV validator instance (check [the AJV options documentation](https://github.com/epoberezkin/ajv#options) for the syntax and available options). |


### Invokers

#### `{validator}.validate(key, content)`

* `key {String}`:  The schema key we are validating against.
* `content {Object}`: The JSON content we are validating.
* Returns: An `{Object}` describing the errors, or `undefined` if there are no errors.

The raw output provided by AJV is run through `sanitizeValidationErrors` (see below) to provide more user-friendly
feedback where possible.

### Static Functions


#### `gpii.schema.validator.ajv.sanitizeValidationErrors(schemaKey, errors)`

* `schemaKey {String}`: The schema key we are validating against.
* `errors`: A map of existing error results to be sanitized (see below for examples).

AJV gives us output like:

```
 [
     {
         "keyword": "minLength",
         "schemaPath": "/password/minLength",
         "dataPath": ".password",
         "message": "should NOT be shorter than 8 characters"
     },
     {
         "keyword": "pattern",
         "schemaPath": "/password/allOf/1/pattern",
         "dataPath": ".password",
         "message": "should match pattern \"[A-Z]+\""
     },
     {
         "keyword": "required",
         "schemaPath": "/deep/required/0",
         "dataPath": ".deep.required",
         "message": "is a required property"
     }
 ]
```

This function uses [`gpii.schema.errors.evolveError`](evolveErrors.md) to look for `errors` definitions that match the `schemaPath` output
from the validator. If it finds them, it replaces `message` with alternate wording, so that we end up with output like:

```
 [
     {
         "keyword": "minLength",
         "schemaPath": "/password/minLength",
         "dataPath": ".password",
         "message": "Passwords must be at least 8 characters long."
     },
     {
         "keyword": "pattern",
         "schemaPath": "/password/allOf/1/pattern",
         "dataPath": ".password",
         "message": "Passwords must contain at least one uppercase character."
     },
     {
         "keyword": "required",
         "schemaPath": "/deep/required/0",
         "dataPath": ".deep.required",
         "message": "You must enter a value for the 'deeply required' field."
     }
 ]
```
See [the documentation for `evolveError`](evolveErrors.md) for more details.

Note that `dataPath` values are ["Javascript property access notation"](https://github.com/epoberezkin/ajv#validation-errors).
These values are URI encoded along the way, and as such, slashes in element names are replaced with `~1`.  To avoid
mangling `/1`, tildes are escaped as `~0`. See [the relevant AJV functions for more information](https://github.com/epoberezkin/ajv/blob/3806b9d8a3d11a23ee505bcc8e9eb4907b4cd328/lib/compile/util.js#L270).

# gpii.schema.validator.ajv.server

A server-side component which loads and dereferences all schemas on startup.

## Component options

Supports all options from `gpii.schema.validator.ajv` as well as the following unique options:

| Option       | Type     | Description |
| ------------ | -------- | ----------- |
| `schemaDirs` | `Object` | The path to one or more schema directories that contain the files we can validate against.  This is expected to be an array of package-relative paths such as `%gpii-handlebars/tests/schemas`. |

# Displaying validation messages onscreen

The [`errorBinder`](errorBinder.md) component included with this package is designed to associate the validation error
messages produced by `gpii.schema.validator` with on-screen elements.  See that component's documentation for details.

# Reusing Content between Schemas

One of the key strengths of JSON Schema is that it allows you to compose a complex schema out of parts taken from
other schemas.  The validator in this package supports references between JSON Schemas.

Inheritance is still a sticking point at least in v4 of the draft standard.   You cannot safely expect to overlay
multiple schemas on top of each other.  Best practice for now is to only reuse individual definitions between schemas,
and to explicitly specify each schema's required properties.

Inheritance within and between schemas is handled using `$ref` references, as in:

    $ref: "filename.json#/definitions/field"

These values are expected to be relative or absolute URLs, in our case the exactly correspond to the filename of the schema.

To give an example, suppose we have a simple `person` schema:

```
{
  "id": "person.json",
  "definitions": {
    "firstname": { type: "string" },
    "lastname":  { type: "string" }
  },
  properties: {
    "firstname": { "$ref": "#/definitions/firstname" },
    "lastname":  { "$ref": "#/definitions/lastname" }
  }
}
```

We can add our own properties in a number of ways, but here is the approach we favor at the moment:

```
{
  "id": "reachable-person.json",
  "definitions": {
    "email": { "type": "string", "format": "email" }
  },
  properties: {
    "firstname": { "$ref": "person.json#/definitions/firstname" },
    "lastname":  { "$ref": "person.json#/definitions/lastname" },
    "email":     { "$ref": "#/definitions/email" }
  }
}
```

See the test schemas (particularly `derived.json` and `evolved-overlay.json`) for additional examples.